#!/usr/bin/env ruby

require 'rubygems'
require 'yaml'
require 'active_record'
require 'action_mailer'
require 'fileutils'
require 'daemon_spawn'

%w(
  ../../lib
  ../../app
).each do |dir|
  libdir = File.expand_path(dir, __FILE__)
  $LOAD_PATH.unshift(libdir) unless $LOAD_PATH.include?(libdir)
end

class Dcc < DaemonSpawn::Base
  def start(args)
    File.umask(0022)
    config = YAML::load(File.read('config/worker.yml')).symbolize_keys
    ActiveRecord::Base.establish_connection(
        YAML::load(File.read('config/database.yml'))[config[:environment]])

    require 'dcc/worker'
    require 'dcc/mailer'

    ActionMailer::Base.delivery_method = :sendmail
    ActionMailer::Base.sendmail_settings = {:arguments => ''}
    DCC::Mailer.default from: config[:email_sender], to: config[:admin_e_mail_address]

    ActiveRecord::Base.time_zone_aware_attributes = true
    ActiveRecord::Base.default_timezone = :utc

    # http://zerolith.com/mysql-server-has-gone-away-activerecord.html
    Thread.new {
      loop {
        sleep 30.minutes
        ActiveRecord::Base.verify_active_connections!
      }
    }.priority = -10

    DCC::Worker.new(config[:group_name], config[:memcache_servers], config).run
  end

  def stop
  end
end

working_dir = log_dir = tmp_dir = pid_file = nil
FileUtils.chdir("#{File.dirname(__FILE__)}/..") do
  working_dir = FileUtils.pwd
  FileUtils.mkdir_p(log_dir = "#{working_dir}/log")
  FileUtils.mkdir_p(tmp_dir = "#{working_dir}/tmp")
  pid_file = "#{tmp_dir}/worker.pid"
  if File.exists?(pid_file) && !system("kill -0 #{File.read pid_file} > /dev/null 2>&1")
    puts "removing orphaned pid file"
    FileUtils.rm_f pid_file
  end
end

lock_file = "#{tmp_dir}/worker.lock"
lock = File.open(lock_file, File::RDWR|File::CREAT)
unless lock.flock(File::LOCK_EX | File::LOCK_NB)
  raise "Another dcc-worker request is currently being processed"
end

command = ARGV.first

Dcc.spawn!(:log_file => "#{log_dir}/worker.log",
    :pid_file => pid_file,
    :working_dir => working_dir,
    :sync_log => true)

if command == 'start'
  print "Wait for startup"
  $stdout.flush
  while !File.exists?(pid_file) || File.size(pid_file) == 0
    print "."
    $stdout.flush
    sleep 1
  end
  puts " #{File.read pid_file}"
end

lock.flock(File::LOCK_UN)
lock.close
